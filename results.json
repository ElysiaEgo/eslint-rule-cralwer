[{"name":"no-const-assign","link":"/docs/latest/rules/no-const-assign","description":"Disallow reassigning const variables","unclassified":[],"correct":["/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\nconsole.log(a);\n","/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nfor (const a in [1, 2, 3]) { // `a` is re-defined (not modified) on each loop step.\n    console.log(a);\n}\n","/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nfor (const a of [1, 2, 3]) { // `a` is re-defined (not modified) on each loop step.\n    console.log(a);\n}\n"],"incorrect":["/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\na = 1;\n","/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\na += 1;\n","/*eslint no-const-assign: \"error\"*/\n/*eslint-env es6*/\n\nconst a = 0;\n++a;\n"]},{"name":"array-callback-return","link":"/docs/latest/rules/array-callback-return","description":"Enforce return statements in callbacks of array methods","unclassified":["// example: convert ['a', 'b', 'c'] --> {a: 0, b: 1, c: 2}\nvar indexMap = myArray.reduce(function(memo, item, index) {\n  memo[item] = index;\n}, {}); // Error: cannot set property 'b' of undefined\n"],"correct":["/*eslint array-callback-return: \"error\"*/\n\nvar indexMap = myArray.reduce(function(memo, item, index) {\n    memo[item] = index;\n    return memo;\n}, {});\n\nvar foo = Array.from(nodes, function(node) {\n    if (node.tagName === \"DIV\") {\n        return true;\n    }\n    return false;\n});\n\nvar bar = foo.map(node => node.getAttribute(\"id\"));\n","/*eslint array-callback-return: [\"error\", { allowImplicit: true }]*/\nvar undefAllTheThings = myArray.map(function(item) {\n    return;\n});\n","/*eslint array-callback-return: [\"error\", { checkForEach: true }]*/\n\nmyArray.forEach(function(item) {\n    handleItem(item)\n});\n\nmyArray.forEach(function(item) {\n    if (item < 0) {\n        return;\n    }\n    handleItem(item);\n});\n\nmyArray.forEach(function(item) {\n    handleItem(item);\n    return;\n});\n\nmyArray.forEach(item => {\n    handleItem(item);\n});\n","/*eslint array-callback-return: [\"error\", { checkForEach: true, allowVoid: true }]*/\n\nmyArray.forEach(item => void handleItem(item));\n\nmyArray.forEach(item => {\n    return void handleItem(item);\n});\n\nmyArray.forEach(item => {\n    if (item < 0) {\n        return void x;\n    }\n    handleItem(item);\n});\n"],"incorrect":["/*eslint array-callback-return: \"error\"*/\n\nvar indexMap = myArray.reduce(function(memo, item, index) {\n    memo[item] = index;\n}, {});\n\nvar foo = Array.from(nodes, function(node) {\n    if (node.tagName === \"DIV\") {\n        return true;\n    }\n});\n\nvar bar = foo.filter(function(x) {\n    if (x) {\n        return true;\n    } else {\n        return;\n    }\n});\n","/*eslint array-callback-return: [\"error\", { checkForEach: true }]*/\n\nmyArray.forEach(function(item) {\n    return handleItem(item);\n});\n\nmyArray.forEach(function(item) {\n    if (item < 0) {\n        return x;\n    }\n    handleItem(item);\n});\n\nmyArray.forEach(function(item) {\n    if (item < 0) {\n        return void x;\n    }\n    handleItem(item);\n});\n\nmyArray.forEach(item => handleItem(item));\n\nmyArray.forEach(item => void handleItem(item));\n\nmyArray.forEach(item => {\n    return handleItem(item);\n});\n\nmyArray.forEach(item => {\n    return void handleItem(item);\n});\n"]},{"name":"no-compare-neg-zero","link":"/docs/latest/rules/no-compare-neg-zero","description":"Disallow comparing against -0","unclassified":[],"correct":["/* eslint no-compare-neg-zero: \"error\" */\n\nif (x === 0) {\n    // doSomething()...\n}\n","/* eslint no-compare-neg-zero: \"error\" */\n\nif (Object.is(x, -0)) {\n    // doSomething()...\n}\n"],"incorrect":["/* eslint no-compare-neg-zero: \"error\" */\n\nif (x === -0) {\n    // doSomething()...\n}\n"]},{"name":"no-class-assign","link":"/docs/latest/rules/no-class-assign","description":"Disallow reassigning class members","unclassified":["/*eslint-env es6*/\n\nclass A { }\nA = 0;\n"],"correct":["/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nlet A = class A { }\nA = 0; // A is a variable.\n","/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nlet A = class {\n    b() {\n        A = 0; // A is a variable.\n    }\n}\n","/*eslint no-class-assign: 2*/\n/*eslint-env es6*/\n\nclass A {\n    b(A) {\n        A = 0; // A is a parameter.\n    }\n}\n"],"incorrect":["/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nclass A { }\nA = 0;\n","/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nA = 0;\nclass A { }\n","/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    b() {\n        A = 0;\n    }\n}\n","/*eslint no-class-assign: \"error\"*/\n/*eslint-env es6*/\n\nlet A = class A {\n    b() {\n        A = 0;\n        // `let A` is shadowed by the class name.\n    }\n}\n"]},{"name":"no-await-in-loop","link":"/docs/latest/rules/no-await-in-loop","description":"Disallow await inside of loops","unclassified":["async function foo(things) {\n  const results = [];\n  for (const thing of things) {\n    // Bad: each loop iteration is delayed until the entire asynchronous operation completes\n    results.push(await bar(thing));\n  }\n  return baz(results);\n}\n","async function foo(things) {\n  const results = [];\n  for (const thing of things) {\n    // Good: all asynchronous operations are immediately started.\n    results.push(bar(thing));\n  }\n  // Now that all the asynchronous operations are running, here we wait until they all complete.\n  return baz(await Promise.all(results));\n}\n"],"correct":["/*eslint no-await-in-loop: \"error\"*/\n\nasync function foo(things) {\n  const results = [];\n  for (const thing of things) {\n    // Good: all asynchronous operations are immediately started.\n    results.push(bar(thing));\n  }\n  // Now that all the asynchronous operations are running, here we wait until they all complete.\n  return baz(await Promise.all(results));\n}\n"],"incorrect":["/*eslint no-await-in-loop: \"error\"*/\n\nasync function foo(things) {\n  const results = [];\n  for (const thing of things) {\n    // Bad: each loop iteration is delayed until the entire asynchronous operation completes\n    results.push(await bar(thing));\n  }\n  return baz(results);\n}\n"]},{"name":"constructor-super","link":"/docs/latest/rules/constructor-super","description":"Require super() calls in constructors","unclassified":["class A {\n    constructor() {\n        super();\n    }\n}\n"],"correct":["/*eslint constructor-super: \"error\"*/\n/*eslint-env es6*/\n\nclass A {\n    constructor() { }\n}\n\nclass B extends C {\n    constructor() {\n        super();\n    }\n}\n"],"incorrect":["/*eslint constructor-super: \"error\"*/\n/*eslint-env es6*/\n\nclass A extends B {\n    constructor() { }  // Would throw a ReferenceError.\n}\n\n// Classes which inherits from a non constructor are always problems.\nclass C extends null {\n    constructor() {\n        super();  // Would throw a TypeError.\n    }\n}\n\nclass D extends null {\n    constructor() { }  // Would throw a ReferenceError.\n}\n"]},{"name":"no-async-promise-executor","link":"/docs/latest/rules/no-async-promise-executor","description":"Disallow using an async function as a Promise executor","unclassified":["const result = new Promise(function executor(resolve, reject) {\n  readFile('foo.txt', function(err, result) {\n    if (err) {\n      reject(err);\n    } else {\n      resolve(result);\n    }\n  });\n});\n"],"correct":["/*eslint no-async-promise-executor: \"error\"*/\n\nconst foo = new Promise((resolve, reject) => {\n  readFile('foo.txt', function(err, result) {\n    if (err) {\n      reject(err);\n    } else {\n      resolve(result);\n    }\n  });\n});\n\nconst result = Promise.resolve(foo);\n"],"incorrect":["/*eslint no-async-promise-executor: \"error\"*/\n\nconst foo = new Promise(async (resolve, reject) => {\n  readFile('foo.txt', function(err, result) {\n    if (err) {\n      reject(err);\n    } else {\n      resolve(result);\n    }\n  });\n});\n\nconst result = new Promise(async (resolve, reject) => {\n  resolve(await foo);\n});\n"]},{"name":"no-cond-assign","link":"/docs/latest/rules/no-cond-assign","description":"Disallow assignment operators in conditional expressions","unclassified":["// Check the user's job title\nif (user.jobTitle = \"manager\") {\n    // user.jobTitle is now incorrect\n}\n"],"correct":["/*eslint no-cond-assign: \"error\"*/\n\n// Assignment replaced by comparison\nvar x;\nif (x === 0) {\n    var b = 1;\n}\n\n// Practical example that wraps the assignment in parentheses\nvar setHeight = function (someNode) {\n    do {\n        someNode.height = \"100px\";\n    } while ((someNode = someNode.parentNode));\n}\n\n// Practical example that wraps the assignment and tests for 'null'\nvar setHeight = function (someNode) {\n    do {\n        someNode.height = \"100px\";\n    } while ((someNode = someNode.parentNode) !== null);\n}\n","/*eslint no-cond-assign: [\"error\", \"always\"]*/\n\n// Assignment replaced by comparison\nvar x;\nif (x === 0) {\n    var b = 1;\n}\n"],"incorrect":["/*eslint no-cond-assign: \"error\"*/\n\n// Unintentional assignment\nvar x;\nif (x = 0) {\n    var b = 1;\n}\n\n// Practical example that is similar to an error\nvar setHeight = function (someNode) {\n    do {\n        someNode.height = \"100px\";\n    } while (someNode = someNode.parentNode);\n}\n","/*eslint no-cond-assign: [\"error\", \"always\"]*/\n\n// Unintentional assignment\nvar x;\nif (x = 0) {\n    var b = 1;\n}\n\n// Practical example that is similar to an error\nvar setHeight = function (someNode) {\n    do {\n        someNode.height = \"100px\";\n    } while (someNode = someNode.parentNode);\n}\n\n// Practical example that wraps the assignment in parentheses\nvar setHeight = function (someNode) {\n    do {\n        someNode.height = \"100px\";\n    } while ((someNode = someNode.parentNode));\n}\n\n// Practical example that wraps the assignment and tests for 'null'\nvar setHeight = function (someNode) {\n    do {\n        someNode.height = \"100px\";\n    } while ((someNode = someNode.parentNode) !== null);\n}\n"]},{"name":"for-direction","link":"/docs/latest/rules/for-direction","description":"Enforce “for” loop update clause moving the counter in the right direction","unclassified":[],"correct":["/*eslint for-direction: \"error\"*/\nfor (var i = 0; i < 10; i++) {\n}\n\nfor (var i = 0; 10 > i; i++) { // with counter \"i\" on the right\n}\n\nfor (let i = 10; i >= 0; i += this.step) { // direction unknown\n}\n\nfor (let i = MIN; i <= MAX; i -= 0) { // not increasing or decreasing\n}\n"],"incorrect":["/*eslint for-direction: \"error\"*/\nfor (var i = 0; i < 10; i--) {\n}\n\nfor (var i = 10; i >= 0; i++) {\n}\n\nfor (var i = 0; i > 10; i++) {\n}\n\nfor (var i = 0; 10 > i; i--) {\n}\n\nconst n = -2;\nfor (let i = 0; i < 10; i += n) {\n}\n"]},{"name":"getter-return","link":"/docs/latest/rules/getter-return","description":"Enforce return statements in getters","unclassified":["var p = {\n    get name(){\n        return \"nicholas\";\n    }\n};\n\nObject.defineProperty(p, \"age\", {\n    get: function (){\n        return 17;\n    }\n});\n"],"correct":["/*eslint getter-return: \"error\"*/\n\np = {\n    get name(){\n        return \"nicholas\";\n    }\n};\n\nObject.defineProperty(p, \"age\", {\n    get: function (){\n        return 18;\n    }\n});\n\nclass P{\n    get name(){\n        return \"nicholas\";\n    }\n}\n","/*eslint getter-return: [\"error\", { allowImplicit: true }]*/\np = {\n    get name(){\n        return; // return undefined implicitly.\n    }\n};\n"],"incorrect":["/*eslint getter-return: \"error\"*/\n\np = {\n    get name(){\n        // no returns.\n    }\n};\n\nObject.defineProperty(p, \"age\", {\n    get: function (){\n        // no returns.\n    }\n});\n\nclass P{\n    get name(){\n        // no returns.\n    }\n}\n"]}]